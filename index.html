<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Unrealised CGT to Centric CSV Processor</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.4.1/papaparse.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            border-radius: 20px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            overflow: hidden;
            position: relative;
        }

        .refresh-btn {
            position: absolute;
            top: 30px;
            right: 30px;
            background: rgba(255, 255, 255, 0.2);
            border: 2px solid white;
            color: white;
            padding: 10px 20px;
            border-radius: 25px;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.3s ease;
            z-index: 10;
        }

        .refresh-btn:hover {
            background: rgba(255, 255, 255, 0.3);
            transform: translateY(-2px);
        }

        .header {
            background: linear-gradient(135deg, #5e72e4 0%, #825ee4 100%);
            color: white;
            padding: 30px;
            text-align: center;
        }

        .header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
        }

        .header p {
            opacity: 0.9;
            font-size: 1.1em;
        }

        .main-content {
            padding: 40px;
        }

        .format-selector {
            background: #f8f9ff;
            padding: 20px;
            border-radius: 10px;
            margin-bottom: 30px;
            display: flex;
            align-items: center;
            gap: 20px;
        }

        .format-selector label {
            font-weight: 600;
            color: #555;
        }

        .format-selector select {
            padding: 10px 15px;
            border: 2px solid #667eea;
            border-radius: 8px;
            font-size: 1em;
            background: white;
            cursor: pointer;
            min-width: 200px;
        }

        .format-selector select:focus {
            outline: none;
            border-color: #825ee4;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }

        .upload-section {
            border: 3px dashed #667eea;
            border-radius: 15px;
            padding: 40px;
            text-align: center;
            transition: all 0.3s ease;
            background: #f8f9ff;
            cursor: pointer;
        }

        .upload-section:hover {
            border-color: #825ee4;
            background: #f0f2ff;
        }

        .upload-section.dragover {
            background: #e8ebff;
            transform: scale(1.02);
        }

        .upload-icon {
            font-size: 4em;
            color: #667eea;
            margin-bottom: 20px;
        }

        .file-input {
            display: none;
        }

        .upload-label {
            display: inline-block;
            padding: 12px 30px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border-radius: 25px;
            cursor: pointer;
            transition: transform 0.3s ease;
            font-weight: 600;
        }

        .upload-label:hover {
            transform: translateY(-2px);
        }

        .file-list {
            margin-top: 30px;
        }

        .file-item {
            background: white;
            border: 1px solid #e0e0e0;
            border-radius: 10px;
            padding: 15px;
            margin-bottom: 15px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            transition: all 0.3s ease;
        }

        .file-item:hover {
            box-shadow: 0 5px 15px rgba(0,0,0,0.1);
        }

        .file-info {
            display: flex;
            align-items: center;
            gap: 15px;
        }

        .file-icon {
            font-size: 2em;
            color: #667eea;
        }

        .btn {
            padding: 10px 20px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.3s ease;
        }

        .btn-process {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            font-size: 1.1em;
            padding: 15px 40px;
            border-radius: 25px;
            margin-top: 20px;
        }

        .btn-process:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 20px rgba(102, 126, 234, 0.4);
        }

        .btn-process:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .btn-remove {
            background: #ff4757;
            color: white;
        }

        .btn-remove:hover {
            background: #ff3838;
        }

        .results-section {
            margin-top: 40px;
            display: none;
        }

        .results-header {
            background: #f8f9ff;
            padding: 20px;
            border-radius: 10px;
            margin-bottom: 20px;
        }

        .asset-card {
            background: white;
            border: 1px solid #e0e0e0;
            border-radius: 10px;
            padding: 20px;
            margin-bottom: 20px;
            transition: all 0.3s ease;
        }

        .asset-card:hover {
            box-shadow: 0 5px 15px rgba(0,0,0,0.1);
        }

        .asset-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            padding-bottom: 15px;
            border-bottom: 2px solid #f0f0f0;
        }

        .asset-name {
            font-size: 1.2em;
            font-weight: 600;
            color: #333;
        }

        .asset-count {
            background: #667eea;
            color: white;
            padding: 5px 15px;
            border-radius: 15px;
            font-size: 0.9em;
        }

        .table-container {
            overflow-x: auto;
            margin-top: 15px;
        }

        table {
            width: 100%;
            border-collapse: collapse;
        }

        th {
            background: #f8f9ff;
            padding: 12px;
            text-align: left;
            font-weight: 600;
            color: #555;
            border-bottom: 2px solid #e0e0e0;
        }

        td {
            padding: 10px 12px;
            border-bottom: 1px solid #f0f0f0;
        }

        tr:hover {
            background: #fafbff;
        }

        .btn-download {
            background: linear-gradient(135deg, #00d2ff 0%, #3a7bd5 100%);
            color: white;
            padding: 8px 20px;
            border-radius: 20px;
            font-size: 0.9em;
        }

        .btn-download:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(58, 123, 213, 0.4);
        }

        .loading {
            display: none;
            text-align: center;
            padding: 40px;
        }

        .spinner {
            border: 4px solid #f3f3f3;
            border-top: 4px solid #667eea;
            border-radius: 50%;
            width: 50px;
            height: 50px;
            animation: spin 1s linear infinite;
            margin: 0 auto 20px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .status-message {
            margin-top: 20px;
            padding: 15px;
            border-radius: 10px;
            display: none;
        }

        .status-success {
            background: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }

        .status-error {
            background: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }

        .status-info {
            background: #d1ecf1;
            color: #0c5460;
            border: 1px solid #bee5eb;
        }

        .debug-section {
            margin-top: 20px;
            padding: 20px;
            background: #f8f9ff;
            border-radius: 10px;
            display: none;
        }

        .debug-content {
            font-family: monospace;
            font-size: 0.9em;
            white-space: pre-wrap;
            max-height: 300px;
            overflow-y: auto;
            background: white;
            padding: 10px;
            border-radius: 5px;
            margin-top: 10px;
        }
    </style>
</head>
<body>
    <div class="container">
        <button class="refresh-btn" onclick="refreshPage()">🔄 Refresh</button>
        <div class="header">
            <h1>📊 Unrealised CGT to Centric Processor</h1>
            <p>Convert Unrealised Capital Gains reports to Centric-compatible CSV format</p>
        </div>

        <div class="main-content">
            <div class="format-selector">
                <label for="formatSelect">Report Format:</label>
                <select id="formatSelect">
                    <option value="findex">FINDEX Report</option>
                    <option value="external">External Accountant Report</option>
                    <option value="lifefocus">LifeFocus Report</option>
                </select>
                <span style="color: #666; font-size: 0.9em;">Select your report format or leave on auto-detect</span>
            </div>

            <div class="upload-section" id="uploadSection">
                <div class="upload-icon">📁</div>
                <h2>Upload Unrealised CGT Reports</h2>
                <p style="margin: 20px 0; color: #666;">Drag & drop PDF files here or click to browse</p>
                <label for="fileInput" class="upload-label">Choose Files</label>
                <input type="file" id="fileInput" class="file-input" accept=".pdf" multiple>
                <p style="margin-top: 20px; color: #999; font-size: 0.9em;">Supports FINDEX, LifeFocus, and external accountant formats</p>
            </div>

            <div class="file-list" id="fileList"></div>

            <div style="text-align: center;">
                <button class="btn btn-process" id="processBtn" style="display: none;" onclick="processFiles()">
                    Process Files
                </button>
            </div>

            <div class="loading" id="loading">
                <div class="spinner"></div>
                <p>Processing your files...</p>
            </div>

            <div class="status-message" id="statusMessage"></div>

            <div class="debug-section" id="debugSection">
                <h3>Debug Output</h3>
                <div class="debug-content" id="debugContent"></div>
            </div>

            <div class="results-section" id="resultsSection">
                <div class="results-header">
                    <h2>📈 Processed Tax Parcels</h2>
                    <p style="margin-top: 10px; color: #666;">Review the extracted data and download CSV files for each asset</p>
                </div>
                <div id="resultsContainer"></div>
            </div>
        </div>
    </div>

    <script>
        // Global variables
        let uploadedFiles = [];
        let processedData = {};
        let debugMode = true; // Enable debug mode for troubleshooting

        // Configure PDF.js
        pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';

        // Refresh button function
        function refreshPage() {
            location.reload();
        }

        // File upload handling
        const uploadSection = document.getElementById('uploadSection');
        const fileInput = document.getElementById('fileInput');
        const fileList = document.getElementById('fileList');
        const processBtn = document.getElementById('processBtn');
        const formatSelect = document.getElementById('formatSelect');

        // Drag and drop
        uploadSection.addEventListener('dragover', (e) => {
            e.preventDefault();
            uploadSection.classList.add('dragover');
        });

        uploadSection.addEventListener('dragleave', () => {
            uploadSection.classList.remove('dragover');
        });

        uploadSection.addEventListener('drop', (e) => {
            e.preventDefault();
            uploadSection.classList.remove('dragover');
            handleFiles(e.dataTransfer.files);
        });

        uploadSection.addEventListener('click', () => {
            fileInput.click();
        });

        fileInput.addEventListener('change', (e) => {
            handleFiles(e.target.files);
        });

        function handleFiles(files) {
            for (let file of files) {
                if (file.type === 'application/pdf') {
                    uploadedFiles.push(file);
                }
            }
            updateFileList();
        }

        function updateFileList() {
            fileList.innerHTML = '';
            
            if (uploadedFiles.length === 0) {
                processBtn.style.display = 'none';
                return;
            }

            processBtn.style.display = 'inline-block';

            uploadedFiles.forEach((file, index) => {
                const fileItem = document.createElement('div');
                fileItem.className = 'file-item';
                fileItem.innerHTML = `
                    <div class="file-info">
                        <div class="file-icon">📄</div>
                        <div>
                            <div style="font-weight: 600;">${file.name}</div>
                            <div style="color: #999; font-size: 0.9em;">${(file.size / 1024).toFixed(2)} KB</div>
                        </div>
                    </div>
                    <button class="btn btn-remove" onclick="removeFile(${index})">Remove</button>
                `;
                fileList.appendChild(fileItem);
            });
        }

        function removeFile(index) {
            uploadedFiles.splice(index, 1);
            updateFileList();
        }

        async function processFiles() {
            if (uploadedFiles.length === 0) return;

            document.getElementById('loading').style.display = 'block';
            document.getElementById('resultsSection').style.display = 'none';
            if (debugMode) {
                document.getElementById('debugSection').style.display = 'block';
            }
            processBtn.disabled = true;
            processedData = {};

            try {
                for (let file of uploadedFiles) {
                    await processPDF(file);
                }
                displayResults();
                showStatus('Files processed successfully!', 'success');
            } catch (error) {
                console.error('Error processing files:', error);
                showStatus('Error processing files. Please check the console for details.', 'error');
                if (debugMode) {
                    addDebugInfo('Error: ' + error.message);
                }
            } finally {
                document.getElementById('loading').style.display = 'none';
                processBtn.disabled = false;
            }
        }

        // Enhanced text extraction for LifeFocus format
        async function extractStructuredText(page) {
            const textContent = await page.getTextContent();
            const viewport = page.getViewport({ scale: 1.0 });
            
            // Group text items by Y position (to preserve rows)
            const textByLine = {};
            
            textContent.items.forEach(item => {
                if (!item.str || item.str.trim() === '') return;
                
                // Round Y position to group items on the same line
                const y = Math.round(item.transform[5]);
                
                if (!textByLine[y]) {
                    textByLine[y] = [];
                }
                
                textByLine[y].push({
                    text: item.str,
                    x: item.transform[4]
                });
            });
            
            // Sort lines by Y position (top to bottom)
            const sortedLines = Object.keys(textByLine)
                .sort((a, b) => parseInt(b) - parseInt(a))
                .map(y => {
                    // Sort items within each line by X position (left to right)
                    const sortedItems = textByLine[y].sort((a, b) => a.x - b.x);
                    return sortedItems.map(item => item.text).join(' ');
                });
            
            return sortedLines.join('\n');
        }

        async function processPDF(file) {
            const arrayBuffer = await file.arrayBuffer();
            const pdf = await pdfjsLib.getDocument({ data: arrayBuffer }).promise;
            
            const selectedFormat = formatSelect.value;
            
            if (selectedFormat === 'lifefocus') {
                // Use enhanced extraction for LifeFocus
                let structuredText = '';
                
                for (let i = 1; i <= pdf.numPages; i++) {
                    const page = await pdf.getPage(i);
                    const pageText = await extractStructuredText(page);
                    structuredText += pageText + '\n\n';
                }
                
                if (debugMode) {
                    addDebugInfo(`=== LIFEFOCUS STRUCTURED EXTRACTION ===\n`);
                    addDebugInfo(structuredText.substring(0, 5000));
                    addDebugInfo(`\n=== END STRUCTURED EXTRACTION ===\n`);
                }
                
                parseLifeFocusFormat(structuredText);
            } else {
                // Use original extraction for other formats
                let fullText = '';
                let pageTexts = [];
                
                for (let i = 1; i <= pdf.numPages; i++) {
                    const page = await pdf.getPage(i);
                    const textContent = await page.getTextContent();
                    const pageText = textContent.items.map(item => item.str).join(' ');
                    fullText += pageText + '\n';
                    pageTexts.push(pageText);
                }

                if (debugMode && selectedFormat !== 'lifefocus') {
                    addDebugInfo(`=== EXTRACTION FOR ${file.name} ===\n`);
                    addDebugInfo(fullText.substring(0, 2000));
                }

                if (selectedFormat === 'findex') {
                    parseFindexFormat(fullText);
                } else if (selectedFormat === 'external') {
                    parseExternalFormat(fullText);
                }
            }
        }

        function addDebugInfo(text) {
            const debugContent = document.getElementById('debugContent');
            debugContent.textContent += text + '\n\n';
        }

        function normalizeDate(input) {
            if (/^\d{2}\/\d{2}\/\d{4}$/.test(input)) return input;
            const m = input.match(/^(\d{2})-([A-Z]{3})-(\d{4})$/i);
            if (!m) return input;
            const months = {
                JAN: '01', FEB: '02', MAR: '03', APR: '04', MAY: '05', JUN: '06',
                JUL: '07', AUG: '08', SEP: '09', OCT: '10', NOV: '11', DEC: '12'
            };
            return `${m[1]}/${months[m[2].toUpperCase()] || m[2]}/${m[3]}`;
        }

        /* ---------------- Enhanced LifeFocus format parser ---------------- */
        function parseLifeFocusFormat(text) {
            if (debugMode) addDebugInfo("Parsing as LifeFocus format with structured extraction...");

            // Find the Unrealised CGT section
            const lines = text.split('\n');
            let cgtStartIndex = -1;
            let cgtEndIndex = lines.length;
            
            // Find start of CGT section
            for (let i = 0; i < lines.length; i++) {
                if (lines[i].match(/Unrealised\s+CGT|Purchase\s+date.*Purchase\s+cost.*units/i)) {
                    cgtStartIndex = i;
                    break;
                }
            }
            
            if (cgtStartIndex === -1) {
                if (debugMode) addDebugInfo("Could not find CGT section");
                return;
            }
            
            // Find end of CGT section
            for (let i = cgtStartIndex + 1; i < lines.length; i++) {
                if (lines[i].match(/Transaction\s+Details|Disclaimer|Portfolio\s+Valuation|Performance\s+Summary|Total\s+Unrealised/i)) {
                    cgtEndIndex = i;
                    break;
                }
            }
            
            const cgtLines = lines.slice(cgtStartIndex, cgtEndIndex);
            
            if (debugMode) {
                addDebugInfo(`CGT Section found from line ${cgtStartIndex} to ${cgtEndIndex}`);
                addDebugInfo("First 20 lines of CGT section:");
                addDebugInfo(cgtLines.slice(0, 20).join('\n'));
            }
            
            // Process the CGT section
            let currentAsset = null;
            
            for (let i = 0; i < cgtLines.length; i++) {
                const line = cgtLines[i].trim();
                
                if (!line) continue;
                
                // Check for asset header pattern: "Name (CODE)"
                const assetMatch = line.match(/^(.+?)\s*\(\s*([A-Z0-9_.]+)\s*\)$/);
                if (assetMatch) {
                    const name = assetMatch[1].trim();
                    const code = assetMatch[2].trim();
                    currentAsset = { name, code };
                    
                    if (!processedData[code]) {
                        processedData[code] = [];
                    }
                    
                    if (debugMode) {
                        addDebugInfo(`Found asset: ${code} - ${name}`);
                    }
                    continue;
                }
                
                // Look for data rows - enhanced pattern for structured text
                // Pattern: date, cost, units, date, price, value, gain
                const rowPattern = /(\d{2}-[A-Z]{3}-\d{4})\s+\$?([\d,]+(?:\.\d{2})?)\s+([\d,]+(?:\.\d+)?)\s+(\d{2}-[A-Z]{3}-\d{4})\s+([\d.]+)\s+\$?([\d,]+(?:\.\d{2})?)\s+\$?(-?[\d,]+(?:\.\d{2})?)/i;
                const rowMatch = line.match(rowPattern);
                
                if (rowMatch && currentAsset) {
                    const acquisitionDate = normalizeDate(rowMatch[1]);
                    const purchaseCost = parseFloat(rowMatch[2].replace(/,/g, ''));
                    const units = parseFloat(rowMatch[3].replace(/,/g, ''));
                    
                    if (units > 0 && purchaseCost > 0) {
                        const parcel = {
                            instrumentCode: currentAsset.code,
                            instrumentName: currentAsset.name,
                            type: 'Open Tax Parcel',
                            quantity: units,
                            acquisitionDate: acquisitionDate,
                            costBase: purchaseCost,
                            reducedCostBase: purchaseCost
                        };
                        
                        processedData[currentAsset.code].push(parcel);
                        
                        if (debugMode) {
                            addDebugInfo(`  Added parcel: ${acquisitionDate} - Units: ${units}, Cost: ${purchaseCost}`);
                        }
                    }
                } else if (currentAsset) {
                    // Alternative pattern for rows that might be split across lines
                    const datePattern = /(\d{2}-[A-Z]{3}-\d{4})/g;
                    const numberPattern = /\$?([\d,]+(?:\.\d+)?)/g;
                    
                    const dates = line.match(datePattern);
                    const numbers = line.match(numberPattern);
                    
                    if (dates && dates.length >= 1 && numbers && numbers.length >= 3) {
                        const acquisitionDate = normalizeDate(dates[0]);
                        const purchaseCost = parseFloat(numbers[0].replace(/[$,]/g, ''));
                        const units = parseFloat(numbers[1].replace(/[$,]/g, ''));
                        
                        if (units > 0 && purchaseCost > 0) {
                            const parcel = {
                                instrumentCode: currentAsset.code,
                                instrumentName: currentAsset.name,
                                type: 'Open Tax Parcel',
                                quantity: units,
                                acquisitionDate: acquisitionDate,
                                costBase: purchaseCost,
                                reducedCostBase: purchaseCost
                            };
                            
                            processedData[currentAsset.code].push(parcel);
                            
                            if (debugMode) {
                                addDebugInfo(`  Added parcel (alt): ${acquisitionDate} - Units: ${units}, Cost: ${purchaseCost}`);
                            }
                        }
                    }
                }
            }
            
            // Clean up empty assets
            Object.keys(processedData).forEach(key => {
                if (processedData[key].length === 0) {
                    delete processedData[key];
                }
            });
            
            if (debugMode) {
                addDebugInfo(`\nTotal assets with data: ${Object.keys(processedData).length}`);
                Object.keys(processedData).forEach(code => {
                    addDebugInfo(`${code}: ${processedData[code].length} parcels`);
                });
            }
        }

        /* ---------------- External format parser (unchanged) ---------------- */
        function parseExternalFormat(text) {
            if (debugMode) {
                addDebugInfo("Parsing as External Accountant format...");
            }

            // Find all asset headers
            const assetHeaders = [];
            
            // Pattern for fund codes
            const fundPattern = /([A-Z]{3}\d{4}[A-Z]{2}\d*)\s*[-–]\s*([^0-9\n]+)/g;
            let fundMatch;
            while ((fundMatch = fundPattern.exec(text)) !== null) {
                assetHeaders.push({
                    code: fundMatch[1],
                    name: fundMatch[2].trim(),
                    position: fundMatch.index
                });
            }

            // Pattern for stock codes
            const stockPattern = /([A-Z]{2,6}\.[A-Z]{2}\d*)\s*[-–]\s*([^0-9\n]+)/g;
            let stockMatch;
            while ((stockMatch = stockPattern.exec(text)) !== null) {
                assetHeaders.push({
                    code: stockMatch[1],
                    name: stockMatch[2].trim(),
                    position: stockMatch.index
                });
            }

            // Sort headers by position
            assetHeaders.sort((a, b) => a.position - b.position);

            if (debugMode) {
                addDebugInfo(`Found ${assetHeaders.length} total assets`);
            }

            // Process each asset section
            for (let i = 0; i < assetHeaders.length; i++) {
                const currentAsset = assetHeaders[i];
                const nextPosition = i < assetHeaders.length - 1 ? assetHeaders[i + 1].position : text.length;
                
                // Extract section for this asset
                const assetSection = text.substring(currentAsset.position, nextPosition);
                
                if (!processedData[currentAsset.code]) {
                    processedData[currentAsset.code] = [];
                }

                if (debugMode) {
                    addDebugInfo(`\nProcessing ${currentAsset.code}:`);
                    addDebugInfo(`Section preview: ${assetSection.substring(0, 200)}`);
                }

                // Find all dates in the section
                const datePattern = /(\d{2}\/\d{2}\/\d{4})/g;
                let dateMatch;
                const dates = [];
                while ((dateMatch = datePattern.exec(assetSection)) !== null) {
                    dates.push({
                        date: dateMatch[1],
                        position: dateMatch.index
                    });
                }

                // Process each date
                dates.forEach((dateObj, idx) => {
                    const startPos = dateObj.position;
                    const endPos = idx < dates.length - 1 ? dates[idx + 1].position : assetSection.length;
                    const dateSection = assetSection.substring(startPos, endPos);
                    
                    // Remove the date to get just the numbers
                    const cleanSection = dateSection.replace(/\d{2}\/\d{2}\/\d{4}/, '').trim();
                    
                    // Extract ALL numbers (incl. parentheses)
                    const numberPattern = /\(?([\d,]+\.?\d*)\)?/g;
                    const matches = [...cleanSection.matchAll(numberPattern)];
                    
                    const numbers = matches.map(match => {
                        const isNegative = match[0].includes('(');
                        const value = parseFloat(match[1].replace(/,/g, ''));
                        return { value, isNegative };
                    }).filter(n => !isNaN(n.value));

                    if (debugMode && numbers.length > 0) {
                        const numberValues = numbers.map((n, i) => `[${i}]: ${n.value}`).join(', ');
                        addDebugInfo(`  Numbers found: ${numberValues}`);
                    }

                    if (numbers.length >= 5) {
                        const units = numbers[1].value;
                        const originalCostBase = numbers[2].value;
                        const originalReducedCostBase = numbers[4].value;
                        
                        if (units > 0 && originalCostBase > 0) {
                            const parcel = {
                                instrumentCode: currentAsset.code,
                                instrumentName: currentAsset.name,
                                type: 'Open Tax Parcel',
                                quantity: units,
                                acquisitionDate: dateObj.date,
                                costBase: originalReducedCostBase,   // swap
                                reducedCostBase: originalCostBase     // swap
                            };
                            
                            processedData[currentAsset.code].push(parcel);
                            
                            if (debugMode) {
                                addDebugInfo(`  Added: ${dateObj.date} - Units: ${units}, Cost: ${originalReducedCostBase} (pos5), Reduced: ${originalCostBase} (pos3)`);
                            }
                        }
                    } else if (numbers.length >= 3) {
                        const units = numbers[1] ? numbers[1].value : numbers[0].value;
                        const costBase = numbers[2] ? numbers[2].value : numbers[1].value;
                        
                        if (units > 0 && costBase > 0) {
                            const parcel = {
                                instrumentCode: currentAsset.code,
                                instrumentName: currentAsset.name,
                                type: 'Open Tax Parcel',
                                quantity: units,
                                acquisitionDate: dateObj.date,
                                costBase: costBase,
                                reducedCostBase: costBase
                            };
                            
                            processedData[currentAsset.code].push(parcel);
                            
                            if (debugMode) {
                                addDebugInfo(`  Added (fallback): ${dateObj.date} - Units: ${units}, Cost: ${costBase}`);
                            }
                        }
                    }
                });
            }

            // Clean up empty assets
            Object.keys(processedData).forEach(key => {
                if (processedData[key].length === 0) {
                    delete processedData[key];
                }
            });

            if (debugMode) {
                addDebugInfo(`\nTotal assets with data: ${Object.keys(processedData).length}`);
            }
        }

        /* ---------------- FINDEX format parser (unchanged) ---------------- */
        function parseFindexFormat(text) {
            if (debugMode) {
                addDebugInfo("Parsing as FINDEX format...");
            }

            // Find assets like "Name (ASX:CODE)"
            const assetPattern = /([A-Za-z\.\s&]+?)\s*\(ASX:([A-Z]{2,6})\)/g;
            const assetMatches = [...text.matchAll(assetPattern)];
            
            if (debugMode) {
                addDebugInfo(`Found ${assetMatches.length} assets with ASX codes`);
            }

            // Process each asset section
            assetMatches.forEach((match, index) => {
                const assetName = match[1].trim();
                const assetCode = match[2].trim();

                if (debugMode) addDebugInfo(`Processing asset: ${assetCode} - ${assetName}`);

                if (!processedData[assetCode]) {
                    processedData[assetCode] = [];
                }

                const assetPosition = match.index;
                const nextAssetPosition = index < assetMatches.length - 1 ? assetMatches[index + 1].index : text.length;
                const assetSection = text.substring(assetPosition, nextAssetPosition);

                // Find all holding rows (date + trailing)
                const sectionHoldingPattern = /(\d{2}\/\d{2}\/\d{4})([\s\S]+?)(?=\d{2}\/\d{2}\/\d{4}|$)/g;
                let holdingMatch;
                const parcelDataList = [];

                // Determine Parcel 1 RCB from numbers BEFORE the first date
                let firstDateMatch = assetSection.match(/\d{2}\/\d{2}\/\d{4}/);
                let parcel1ReducedCostBase = null;
                if (firstDateMatch) {
                    const firstDateIndex = firstDateMatch.index;
                    const preChunk = assetSection.substring(0, firstDateIndex);
                    const preNumRe = /-?\(?[\d,]+(?:\.\d+)?\)?/g;
                    const preNums = [];
                    let nm;
                    while ((nm = preNumRe.exec(preChunk)) !== null) {
                        const raw = nm[0];
                        const neg = raw.includes('(');
                        const val = parseFloat(raw.replace(/[(),]/g, ''));
                        if (!isNaN(val)) preNums.push(neg ? -val : val);
                    }
                    // last non-zero number before the date
                    for (let i = preNums.length - 1; i >= 0; i--) {
                        if (Math.abs(preNums[i]) > 0) {
                            parcel1ReducedCostBase = Math.abs(preNums[i]);
                            break;
                        }
                    }
                    if (debugMode) {
                        addDebugInfo(`[${assetCode}] Parcel 1 pre-date numbers: ${preNums.map(n => n.toFixed(2)).join(', ')}`);
                        addDebugInfo(`[${assetCode}] Parcel 1 RCB chosen: ${parcel1ReducedCostBase !== null ? parcel1ReducedCostBase.toFixed(2) : 'fallback to cost base'}`);
                    }
                }

                // Build row-wise number arrays
                while ((holdingMatch = sectionHoldingPattern.exec(assetSection)) !== null) {
                    const date = holdingMatch[1];
                    const numbersSection = holdingMatch[2];

                    const numberPattern = /([\d,]+(?:\.\d+)?)/g;
                    const numberMatches = [...numbersSection.matchAll(numberPattern)];
                    const numbers = numberMatches.map(m => parseFloat(m[1].replace(/,/g, '')))
                                                 .filter(n => !isNaN(n));

                    if (debugMode && numbers.length > 0) {
                        addDebugInfo(`  Date: ${date}`);
                        addDebugInfo(`    All numbers found: ${numbers.map((n, i) => `[${i}]: ${n}`).join(', ')}`);
                    }

                    if (numbers.length >= 3) {
                        parcelDataList.push({
                            date: date,
                            numbers: numbers
                        });
                    }
                }

                // Create parcels with corrected Parcel 1 Reduced Cost Base
                parcelDataList.forEach((parcelData, idx) => {
                    const { date, numbers } = parcelData;
                    let quantity, costBase, reducedCostBase;

                    // Quantity & cost base inference
                    if (numbers[1] > 0 && numbers[1] < numbers[0]) {
                        quantity = numbers[1];
                        costBase = numbers[2];
                    } else if (numbers[0] > 0 && numbers[0] < 100000 && numbers[1] > numbers[0]) {
                        quantity = numbers[0];
                        costBase = numbers[2];
                    } else {
                        quantity = numbers[1];
                        costBase = numbers[2];
                    }

                    // Reduced Cost Base:
                    if (idx === 0) {
                        // Use the last non-zero number before the first date if available
                        reducedCostBase = (parcel1ReducedCostBase !== null) ? parcel1ReducedCostBase : costBase;
                    } else {
                        // keep your previous carry rule
                        const prevNumbers = parcelDataList[idx - 1].numbers;
                        if (prevNumbers.length > 6 && prevNumbers[6] > 0) {
                            reducedCostBase = prevNumbers[6];
                        } else {
                            reducedCostBase = costBase;
                        }
                    }

                    // Sanity
                    if (!quantity || quantity <= 0 || !costBase || costBase <= 0) {
                        if (debugMode) addDebugInfo(`  Skipping parcel due to invalid values`);
                        return;
                    }

                    const parcel = {
                        instrumentCode: assetCode,
                        instrumentName: assetName,
                        type: 'Open Tax Parcel',
                        quantity: quantity,
                        acquisitionDate: date,
                        costBase: costBase,
                        reducedCostBase: reducedCostBase
                    };

                    processedData[assetCode].push(parcel);

                    if (debugMode) {
                        addDebugInfo(`  Added parcel: ${assetCode} - Date: ${date}, Qty: ${quantity}, Cost Base: ${costBase}, Reduced Cost Base: ${reducedCostBase}`);
                    }
                });

                // Clean empty
                if (processedData[assetCode].length === 0) {
                    delete processedData[assetCode];
                }
            });
        }

        /* ---------------- Results UI & CSV ---------------- */
        function displayResults() {
            const resultsContainer = document.getElementById('resultsContainer');
            resultsContainer.innerHTML = '';

            if (Object.keys(processedData).length === 0) {
                resultsContainer.innerHTML = '<p style="text-align: center; color: #999;">No tax parcels found. Please check the format selector and try again, or review the debug output for details.</p>';
                document.getElementById('resultsSection').style.display = 'block';
                return;
            }

            Object.keys(processedData).sort().forEach(assetCode => {
                const parcels = processedData[assetCode];
                if (parcels.length === 0) return;

                const assetCard = document.createElement('div');
                assetCard.className = 'asset-card';

                const assetName = parcels[0].instrumentName || assetCode;

                assetCard.innerHTML = `
                    <div class="asset-header">
                        <div>
                            <div class="asset-name">${assetCode}</div>
                            <div style="color: #666; font-size: 0.9em; margin-top: 5px;">${assetName}</div>
                        </div>
                        <div style="display: flex; gap: 10px; align-items: center;">
                            <div class="asset-count">${parcels.length} parcels</div>
                            <button class="btn btn-download" onclick="downloadCSV('${assetCode}')">
                                Download CSV
                            </button>
                        </div>
                    </div>
                    <div class="table-container">
                        <table>
                            <thead>
                                <tr>
                                    <th>Type</th>
                                    <th>Quantity</th>
                                    <th>Acquisition Date</th>
                                    <th>Cost Base ($)</th>
                                    <th>Reduced Cost Base ($)</th>
                                </tr>
                            </thead>
                            <tbody>
                                ${parcels.map(parcel => `
                                    <tr>
                                        <td>${parcel.type}</td>
                                        <td>${parcel.quantity.toFixed(2)}</td>
                                        <td>${parcel.acquisitionDate}</td>
                                        <td>$${parcel.costBase.toFixed(2)}</td>
                                        <td>$${parcel.reducedCostBase.toFixed(2)}</td>
                                    </tr>
                                `).join('')}
                            </tbody>
                        </table>
                    </div>
                `;

                resultsContainer.appendChild(assetCard);
            });

            document.getElementById('resultsSection').style.display = 'block';
        }

        function downloadCSV(assetCode) {
            const parcels = processedData[assetCode];
            if (!parcels || parcels.length === 0) return;

            const csvData = parcels.map(parcel => ({
                'Instrument Code': assetCode,
                'Type': parcel.type,
                'Number of Shares/ Units': parcel.quantity,
                'Acquisition Date': parcel.acquisitionDate,
                'Disposal Date': '',
                'Cost Base ($)': parcel.costBase,
                'Reduced Cost Base ($)': parcel.reducedCostBase,
                'Disposal Cost ($)': '',
                'Cost Base(AUD)': parcel.costBase,
                'Reduced Cost Base(AUD)': parcel.reducedCostBase,
                'Disposal Cost (AUD)': '',
                'Tax parcel ID': ''
            }));

            const csv = Papa.unparse(csvData);
            const blob = new Blob([csv], { type: 'text/csv' });
            const url = window.URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.download = `${assetCode}_tax_parcels.csv`;
            a.href = url;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            window.URL.revokeObjectURL(url);

            showStatus(`Downloaded ${assetCode}_tax_parcels.csv`, 'success');
        }

        function showStatus(message, type) {
            const statusMessage = document.getElementById('statusMessage');
            statusMessage.textContent = message;
            statusMessage.className = `status-message status-${type}`;
            statusMessage.style.display = 'block';

            setTimeout(() => {
                statusMessage.style.display = 'none';
            }, 5000);
        }
    </script>
</body>
</html>
